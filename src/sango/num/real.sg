###########################################################################
# MIT License                                                             #
# Copyright (c) 2018 Isao Akiyama                                         #
#                                                                         #
# Permission is hereby granted, free of charge, to any person obtaining   #
# a copy of this software and associated documentation files (the         #
# "Software"), to deal in the Software without restriction, including     #
# without limitation the rights to use, copy, modify, merge, publish,     #
# distribute, sublicense, and/or sell copies of the Software, and to      #
# permit persons to whom the Software is furnished to do so, subject to   #
# the following conditions:                                               #
#                                                                         #
# The above copyright notice and this permission notice shall be          #
# included in all copies or substantial portions of the Software.         #
#                                                                         #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,         #
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF      #
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  #
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY    #
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,    #
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE       #
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                  #
###########################################################################
module "sango.num.real" ;;

import "sango.cstr" -> cstr ;;
import "sango.cstr.format" -> fmt ;;
import "sango.string" -> str ;;

# -- parse --

eval <cstr> *Str parse @public -> <real> {
  Str cstr.trim_spaces = *S,
  S case {
  ; "Infinity" | "+Infinity" -> pos_inf
  ; "-Infinity" -> neg_inf
  ; "NaN" -> nan
  ; ** -> S parse_floating_point
  }
} ;;

data <s> :=
| s_just_started$
| s_after_sign$
| s_integer_part$
| s_fraction_part$
| s_exp_part_just_started$
| s_exp_part_after_sign$
| s_exp_part$ ;;

eval <cstr> *Str parse_floating_point @public -> <real> {
  # only check floating point format here. actual parsing is performed in _parse_floating_point
  # '+' = %x2B
  # '-' = %x2D
  # '.' = %x2E
  # 'E' = %x45
  # 'e' = %x65

  Str cstr.trim_spaces = *S,
  S cstr.length = *L,
  0 s_just_started$ &\ <int> *Pos <s> *State -> <real> {
    if {
    ; Pos L lt? ->
      S Pos cstr.char >> char_code = *CC,
      (| State, CC |) case {
      ; (| s_just_started$, %x2B |) -> (Pos inc) s_after_sign$ &&
      ; (| s_just_started$, %x2D |) -> (Pos inc) s_after_sign$ &&
      ; (| s_just_started$, ** |) || CC decimal_digit? -> (Pos inc) s_integer_part$ &&
      ; (| s_just_started$, ** |) -> bad_arg$ "Invalid character at start." new_exception >> throw
      ; (| s_after_sign$, ** |) || CC decimal_digit? -> (Pos inc) s_integer_part$ &&
      ; (| s_after_sign$, ** |) -> bad_arg$ "No decimal digit after sign." new_exception >> throw
      ; (| s_integer_part$, %x2E |) -> (Pos inc) s_fraction_part$ &&
      ; (| s_integer_part$, ** |) || CC decimal_digit? -> (Pos inc) s_integer_part$ &&
      ; (| s_integer_part$, ** |) -> bad_arg$ "Point missing." new_exception >> throw
      ; (| s_fraction_part$, %x45 |) -> (Pos inc) s_exp_part_just_started$ &&
      ; (| s_fraction_part$, %x65 |) -> (Pos inc) s_exp_part_just_started$ &&
      ; (| s_fraction_part$, ** |) || CC decimal_digit? -> (Pos inc) s_fraction_part$ &&
      ; (| s_fraction_part$, ** |) -> bad_arg$ "Invalid character in fraction part." new_exception >> throw
      ; (| s_exp_part_just_started$, %x2B |) -> (Pos inc) s_exp_part_after_sign$ &&
      ; (| s_exp_part_just_started$, %x2D |) -> (Pos inc) s_exp_part_after_sign$ &&
      ; (| s_exp_part_just_started$, ** |) || CC decimal_digit? -> (Pos inc) s_exp_part$ &&
      ; (| s_exp_part_just_started$, ** |) -> bad_arg$ "Invalid character for exponential." new_exception >> throw
      ; (| s_exp_part_after_sign$, ** |) || CC decimal_digit? -> (Pos inc) s_exp_part$ &&
      ; (| s_exp_part_after_sign$, ** |) -> bad_arg$ "Invalid character for exponential." new_exception >> throw
      ; (| s_exp_part$, ** |) || CC decimal_digit? -> (Pos inc) s_exp_part$ &&
      ; (| s_exp_part$, ** |) -> bad_arg$ "Invalid character for exponential." new_exception >> throw
      }
    ; otherwise ->
      State case {
      ; s_just_started$ -> bad_arg$ "Empty." new_exception >> throw
      ; s_after_sign$ -> bad_arg$ "No decimal digit after sign." new_exception >> throw
      ; s_integer_part$ -> S _parse_floating_point
      ; s_fraction_part$ -> S _parse_floating_point
      ; s_exp_part_just_started$ -> bad_arg$ "Fraction part missing." new_exception >> throw
      ; s_exp_part_after_sign$ -> bad_arg$ "No decimal digit for fraction part." new_exception >> throw
      ; s_exp_part$ -> S _parse_floating_point
      }
    }
  }
} ;;

eval <int> *CC decimal_digit? -> <bool> {
  # '0' = %x30
  # '9' = %x39
  (CC %x30 ge?) (CC %x39 le?) and
} ;;

eval <cstr> *S _parse_floating_point -> <real> @native ;;

eval <real> *R default_format | format @public -> <cstr> @native ;;
