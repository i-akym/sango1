###########################################################################
# MIT License                                                             #
# Copyright (c) 2021 AKIYAMA Isao                                         #
#                                                                         #
# Permission is hereby granted, free of charge, to any person obtaining   #
# a copy of this software and associated documentation files (the         #
# "Software"), to deal in the Software without restriction, including     #
# without limitation the rights to use, copy, modify, merge, publish,     #
# distribute, sublicense, and/or sell copies of the Software, and to      #
# permit persons to whom the Software is furnished to do so, subject to   #
# the following conditions:                                               #
#                                                                         #
# The above copyright notice and this permission notice shall be          #
# included in all copies or substantial portions of the Software.         #
#                                                                         #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,         #
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF      #
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  #
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY    #
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,    #
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE       #
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                  #
###########################################################################
module @alpha "sango.util.set.weaksetbase" ;;

import "sango.actor.util" -> actu ;;
import "sango.entity.box" -> box ;;
import "sango.entity.existence" -> ex ;;
import "sango.list" -> list ;;
import "sango.util.avltree.map" -> avlmap ;;
import "sango.util.map" -> map ;;
import "sango.util.map.hashmap" -> hashmap ;;
import "sango.util.set" -> set ;;

alias type <etab> := <int <ex.weak_ref list> map.map> ;;  # existence's hash -> weakref list
alias type <wtab> := <ex.weak_ref int map.map> ;;  # weakref -> existence's hash

data <d> :=
  etab: <etab>
  wtab: <wtab>
  d$ ;;

data <weakset_h> @opaque :=
  mon: <d actu.box_monitor_h>
  weakset_h$ ;;


eval new_set @public -> <weakset_h> {
  etab: (int_ord_fs avlmap.new_map)
    wtab: hashmap.new_map
    d$ = *D,
  D none$ box.create_box = *Box,
  Box actu.create_monitor = *Mon,
  mon: Mon weakset_h$
} ;;

eval <weakset_h> *Set_h empty? -> <bool> {
  (Set_h mon)
    \ <d box.box_h> *Box -> <bool> {
      Box box.read = *D,
      D wtab >> map.empty?
    }
    actu.run
} ;;

eval <weakset_h> *Set_h size -> <int> {
  (Set_h mon)
    \ <d box.box_h> *Box -> <int> {
      Box box.read = *D,
      D wtab >> map.size
    }
    actu.run
} ;;

eval <weakset_h> *Set_h <ex.existence> *Ex get -> <ex.existence maybe> {
  (Set_h mon)
    \ <d box.box_h> *Box -> <ex.existence maybe> {
      Box box.read = *D,
      D Ex d_find = (| *E_, *D' |),
      Box D' box.write,
      E_
    }
    actu.run
} ;;

eval <weakset_h> *Set_h <ex.existence> *Ex contain? -> <bool> {
  Set_h Ex get >> something?
} ;;

eval <weakset_h> *Set_h <ex.existence> *Ex put -> <ex.existence maybe> {
  (Set_h mon)
    \ <d box.box_h> *Box -> <ex.existence maybe> {
      Box box.read = *D,
      D Ex d_remove = (| *Replaced_, *D' |),
      D' Ex (Set_h mon) d_add = *D'',
      Box D'' box.write,
      Replaced_
    }
    actu.run
} ;;

eval <weakset_h> *Set_h <ex.existence> *Ex put_new -> <bool> {
  (Set_h mon)
    \ <d box.box_h> *Box -> <bool> {
      Box box.read = *D,
      D Ex d_find = (| *E_, *D' |),
      E_ case {
      ; none$ -> (| true$, D' Ex (Set_h mon) d_add |)
      ; ** -> (| false$, D' |)
      } = (| *Succeeded?, *D'' |),
      Box D'' box.write,
      Succeeded?
    }
    actu.run
} ;;

eval <weakset_h> *Set_h <ex.existence> *Ex add -> <void> {
  Set_h Ex put >> ignore
} ;;

eval <weakset_h> *Set_h <ex.existence> *Ex remove -> <ex.existence maybe> {
  (Set_h mon)
    \ <d box.box_h> *Box -> <ex.existence maybe> {
      Box box.read = *D,
      D Ex d_remove = (| *Removed_, *D' |),
      Box D' box.write,
      Removed_
    }
    actu.run
} ;;

eval <weakset_h> *Set_h <ex.existence> *Ex delete -> <void> {
  Set_h Ex remove >> ignore
} ;;

eval <weakset_h> *Set_h take -> <ex.existence maybe> {
  (Set_h mon)
    \ <d box.box_h> *Box -> <ex.existence maybe> {
      Box box.read = *D,
      D d_take = (| *E_, *D' |),
      Box D' box.write,
      E_
    }
    actu.run
} ;;

eval <weakset_h> *Set_h clear -> <void> {
  (Set_h mon)
    \ <d box.box_h> *Box -> <void> {
      Box box.read = *D,
      D d_clear = *D',
      Box D' box.write >> ignore
    }
    actu.run
} ;;

# -- data manipulation routines --

eval <d> *D <ex.existence> *Ex d_find -> <<ex.existence maybe> d tuple> {
  D = etab: *ET wtab: *WT *** d$,
  Ex hash = *EH,
  ET EH map.assoc >> case {
  ; *Ws value$ ->
    Ws Ex find_in_candidates = (| *Found_, *Scanned, *To_be_purged |),
    Found_ case {
    ; (| *E, *W, *WW |) value$ -> (| E value$, WW [ W ; Scanned ] list.cons_each |)
    ; ** -> (| none$, Scanned |)
    } = (| *Res, *Ws' |),
    Ws' case {
    ; [] -> ET EH map.delete
    ; ** -> ET EH Ws' map.add
    } = *ET',
    WT To_be_purged map.delete_list = *WT',
    (| Res, etab: ET' wtab: WT' :: D d$ |) 
  ; ** -> (| none$, D |)
  }
} ;;

eval <d> *D <ex.existence> *Ex <d actu.box_monitor_h> *Mon d_add -> <d> {  # add without duplication check
  D = etab: *ET wtab: *WT *** d$,
  Ex hash = *EH,
  \ <ex.weak_ref> *Cleared -> <void> {
    Mon
      \ <d box.box_h> *BB -> <void> {
        BB box.read = *DD,
        DD Cleared d_purge = *DD',
        BB DD' box.write >> ignore
      }
      actu.run
  } = *Lis,
  Ex (Lis value$) ex.create_weak_ref = *W,
  ET EH map.assoc >> case {
  ; *Ws value$ -> [ W ; Ws ]
  ; ** -> [ W ]
  } = *Ws',
  ET EH Ws' map.add = *ET',
  WT W EH map.add = *WT',
  etab: ET' wtab: WT' :: D d$
} ;;

eval <d> *D <ex.existence> *Ex d_remove -> <<ex.existence maybe> d tuple> {
  D = etab: *ET wtab: *WT *** d$,
  Ex hash = *EH,
  ET EH map.assoc >> case {
  ; *Ws value$ ->
    Ws Ex find_in_candidates = (| *Found_, *Scanned, *To_be_purged |),
    Found_ case {
    ; (| *E, *W, *WW |) value$ -> (| E value$, WW Scanned list.cons_each, [ W ; To_be_purged ] |)
    ; ** -> (| none$, Scanned, To_be_purged |)
    } = (| *Res, *Ws', *To_be_purged' |),
    Ws' case {
    ; [] -> ET EH map.delete
    ; ** -> ET EH Ws' map.add
    } = *ET',
    WT To_be_purged' map.delete_list = *WT',
    (| Res, etab: ET' wtab: WT' :: D d$ |) 
  ; ** -> (| none$, D |)
  }
} ;;

eval <d> *D <ex.weak_ref> *Weak_ref d_purge -> <d> {
  D = etab: *ET wtab: *WT *** d$,
  WT Weak_ref map.remove >> case {
  ; (| *WT', (| **, *EH |) value$ |)  ->
    ET EH map.assoc >> case {
    ; *Ws value$ ->
      Ws [] [] &\ <ex.weak_ref list> *To_be_scanned <ex.weak_ref list> *Scanned <ex.weak_ref list> *To_be_purged
          -> <<ex.weak_ref list> <ex.weak_ref list> tuple> {
        To_be_scanned case {
        ; [ Weak_ref ; *To_be_scanned' ] -> (| To_be_scanned' Scanned list.cons_each, To_be_purged |)
        ; [ *W ; *To_be_scanned' ] ->
          W ex.get >> case {
          ; ** value$ -> To_be_scanned' [ W ; Scanned ] To_be_purged &&
          ; ** -> To_be_scanned' Scanned [ W ; To_be_purged ] &&
          }
        ; [] -> (| Scanned, To_be_purged |)
        }
      } = (| *Ws', *PWs |),
      Ws' case {
      ; [] -> ET EH map.delete
      ; ** -> ET EH Ws' map.add
      } = *ET',
      WT' PWs map.delete_list = *WT'',
      etab: ET' wtab: WT'' :: D d$
    ; ** -> D  # not reached here
    }
  ; ** -> D  # already purged
  }
} ;;

eval <d> *D d_take -> <<ex.existence maybe> d tuple> {
  D = etab: *ET wtab: *WT *** d$,
  [] 0 ET WT &\ <ex.weak_ref list> *Ws <int> *EH <etab> *Etab <wtab> *Wtab
      -> <<ex.existence maybe> d tuple> {
    Ws case {
    ; [ *W ; *Ws' ] ->
      Wtab W map.delete = *Wtab',
      W ex.get >> case {
      ; *E value$ ->
        Ws' case {
        ; [] ->
          (| E value$, etab: Etab wtab: Wtab' :: D d$ |)
        ; ** ->
          Etab EH Ws' map.add = *Etab',  # push back
          (| E value$, etab: Etab' wtab: Wtab' :: D d$ |)
        }
      ; none$ ->
        Ws' EH Etab Wtab' &&
      }
    ; [] ->
      Etab map.take >> case {
      ; (| (| *EH', *Ws' |), *Etab' |) value$ -> Ws' EH' Etab' Wtab &&
      ; none$ -> (| none$, etab: Etab wtab: Wtab :: D d$ |)
      }
    }
  }
} ;;

eval <d> *D d_clear -> <d> {
  D = etab: *ET wtab: *WT *** d$,
  etab: (ET map.clear) wtab: (WT map.clear) :: D d$
} ;;

eval <ex.weak_ref list> *Ws <ex.existence> *Ex find_in_candidates
    -> <<<ex.existence ex.weak_ref <ex.weak_ref list> tuple> maybe> <ex.weak_ref list> <ex.weak_ref list> tuple> {
      # (existence, container weak_ref, not yet scanned)?, scanned, to be purged
  Ws [] [] &\ <ex.weak_ref list> *To_be_scanned <ex.weak_ref list> *Scanned <ex.weak_ref list> *To_be_purged
      -> <<<ex.existence ex.weak_ref <ex.weak_ref list> tuple> maybe> <ex.weak_ref list> <ex.weak_ref list> tuple> {
    To_be_scanned case {
    ; [ *W ; *To_be_scanned' ] ->
      W ex.get >> case {
      ; Ex value$ -> (| (| Ex, W, To_be_scanned |) value$, Scanned, To_be_purged |)
      ; ** value$ -> To_be_scanned' [ W ; Scanned ] To_be_purged &&
      ; none$ -> To_be_scanned' Scanned [ W ; To_be_purged ] &&
      }
    ; [] -> (| none$, Scanned, To_be_purged |)
    }
  }
} ;;
