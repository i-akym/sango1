###########################################################################
# MIT License                                                             #
# Copyright (c) 2021 Isao Akiyama                                         #
#                                                                         #
# Permission is hereby granted, free of charge, to any person obtaining   #
# a copy of this software and associated documentation files (the         #
# "Software"), to deal in the Software without restriction, including     #
# without limitation the rights to use, copy, modify, merge, publish,     #
# distribute, sublicense, and/or sell copies of the Software, and to      #
# permit persons to whom the Software is furnished to do so, subject to   #
# the following conditions:                                               #
#                                                                         #
# The above copyright notice and this permission notice shall be          #
# included in all copies or substantial portions of the Software.         #
#                                                                         #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,         #
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF      #
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  #
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY    #
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,    #
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE       #
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                  #
###########################################################################
module "sango.util.avltree.ralist" ;;

import "sango.util.avltree.base" -> base ;;
import "sango.util.ralist" -> ral ;;

data <*A ralist> @opaque :=
  root_: <<A base.node> maybe>
  ralist$ ;;

extend <*A ral.ralist_d> :=
  node_: <<A base.node> maybe>
  d$ ;;

extend <*A base.aux> :=
  count: <int>  # element count here and under
  aux$ ;;

eval aux_builder -> <*A <<A base.node> maybe> <<A base.node> maybe> <A base.aux+> fun> {
  \ <*AA> *Assoc <<AA base.node> maybe> *LN <<AA base.node> maybe> *RN -> <AA base.aux+> {
    ((LN elem_count) (RN elem_count) sum >> inc) aux$
  }
} ;;

eval <<*A base.node> maybe> *Node_ elem_count -> <int> {
  Node_ case {
  ; *Node value$ -> Node base.aux = count: *Count aux$, Count
  ; ** -> 0
  }
} ;;

eval <int> *Index find_locator -> <<*A base.node> <A base.locate> fun> {
  \ <*AA base.node> *N -> <AA base.locate> { 
    N base.left_ >> elem_count = *LC,
    if {
    ; Index LC eq? -> base.just$
    ; Index LC lt? -> ^^ base.left$
    ; otherwise -> ((Index LC diff >> dec) find_locator) base.right$
    }
  }
} ;;

eval <int> *Index insert_locator -> <<*A base.node> <A base.locate> fun> {
  \ <*AA base.node> *N -> <AA base.locate> { 
    N base.left_ >> elem_count = *LC,
    if {
    ; Index LC le? -> ^^ base.left$  # if equals, traverse left
    ; otherwise -> ((Index LC diff >> dec) insert_locator) base.right$
    }
  }
} ;;

eval new_ralist @public -> <*A ral.ralist> {
  d: (node_: none$ d$)
    fs: ralist_fs
    ral.ralist$
} ;;

eval ralist_fs -> <*A ral.ralist_fs> {
  empty?_f_: (^empty? value$)
    length_f: ^length
    elem_f: ^elem
    first_f_: none$
    last_f_: none$
    tail_f_: none$
    insert_at_f: ^insert_at
    append_f_: none$
    remove_at_f: ^remove_at
    replace_at_f_: none$
    take_f_: none$
    drop_f_: none$
    clear_f: ^clear
    ral.ralist_fs$
} ;;

eval <*A ral.ralist_d+> *D empty? -> <bool> {
  D = node_: *Node_ *** d$,
  Node_ nothing?
} ;;

eval <*A ral.ralist_d+> *D length -> <int> {
  D = node_: *Node_ *** d$,
  Node_ elem_count
} ;;

eval <*A ral.ralist_d+> *D <int> *Index elem -> <A maybe> {
  D = node_: *Node_ *** d$,
  Node_ (Index find_locator) base.get
} ;;

eval <*A ral.ralist_d+> *D <int> *Index <A> *X insert_at -> <A ral.ralist_d+> {
  D = node_: *Node_ *** d$,
  Node_ (Index insert_locator) X aux_builder base.put = (| *Node', none$ |),
  node_: (Node' value$) :: D d$
} ;;

eval <*A ral.ralist_d+> *D <int> *Index remove_at -> <<<A ral.ralist_d+> A tuple> maybe> {
  D = node_: *Node_ *** d$,
  Node_ (Index find_locator) aux_builder base.remove >> case {
  ; (| *Node_', *Removed |) value$ ->
    (| node_: Node_' :: D d$, Removed |) value$
  ; none$ -> none$
  }
} ;;

eval <*A ral.ralist_d+> *D clear -> <A ral.ralist_d+> {
  node_: none$ :: D d$
} ;;
